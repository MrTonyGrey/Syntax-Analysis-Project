
/* Function declarations */ 
void  addChar(); 
void  getChar(); 
void  getNonBlank(); 
int  lex();

/* Character classes */ 
#define LETTER 0 
#define DIGIT 1 
#define UNKNOWN 99
/* Token codes */ 
#define INT_LIT 10 
#define IDENT 11 
#define ASSIGN_OP 20 
#define ADD_OP 21 
#define SUB_OP 22 
#define MULT_OP 23 
#define DIV_OP 24 
#define LEFT_PAREN 25 
#define RIGHT_PAREN 26

/* This program will be implementing the following EBNF from page 199 

<expr> → <term> {(+ | -) <term>}
<term> → <factor> {(* | /) <factor>}
<factor> → id | int_constant | ( <expr> )

*/

// Declarations for functions <expr> and <stmt>
 void expr();
 void stmt();

main() /* main driver */    
{
  if  ((in_fp = fopen("front.in", "r")) == NULL)      /* Open the input data file and process its contents */ 
    printf("ERROR - cannot open front.in \n"); 
  else 
  {     
    getChar();     
    do 
    {       
      lex();    
     } while  (nextToken != EOF);  
   } 
}

/* An error function for accounting for errors */
void error(const char * msg)
{
  printf("Error");
  exit(0);
}
 
/* An expected error function for errors */
void expect_error(int EXPECTED_CODE)
{
  // this handles parsing expect errors
  //printf("Parsing Error: Expected %d got token %d, lexeme: %s \n", EXPECTED_CODE, nextToken, lexeme);
  printf("Error");
  exit(0);

}
 

int  lookup(char  ch)  /* lookup - a function to lookup operators and parentheses and return the token */
{  
  switch (ch) 
  {
    case '(':
      addChar();      
      nextToken = LEFT_PAREN;      
      break;
    case ')':      
      addChar();      
      nextToken = RIGHT_PAREN;      
      break;
         
    case '+':      
      addChar();      
      nextToken = ADD_OP;      
      break;
    
    case '-':      
      addChar();      
      nextToken = SUB_OP;      
      break;
    
    case '*':      
      addChar();      
      nextToken = MULT_OP;      
      break;
    
    case  '/':      
      addChar();      
      nextToken = DIV_OP;      
      break;
    
    default:      
      addChar();      
      nextToken = EOF;      
      break;  
  }  
  return  nextToken; 
}
 
void addChar() 
{
  if (lexLen <= 98) 
  {
    lexeme[lexLen++] = nextChar;
    lexeme[lexLen] = 0;
   } 
   else 
   {
    printf("Error - lexeme is too long \n");
   }
}

void getChar() 
{
  if ((nextChar = getc(in_fp)) != EOF) 
  {
    if (isalpha(nextChar))
      charClass = LETTER;
    else if (isdigit(nextChar))
      charClass = DIGIT;
    else charClass = UNKNOWN;
  } 
  else 
  {
    charClass = EOF;
  }
}

void getNonBlank() 
{
  while (isspace(nextChar)) 
    getChar();
}

int lex() 
{
  lexLen = 0;
  getNonBlank();   
  switch (charClass) /* Parse identifiers */
  {
  case LETTER:
    addChar();
    getChar();        
    while (charClass == LETTER || charClass == DIGIT) 
    {
      addChar();
      getChar();
    }
     nextToken = IDENT;
     break;       
     
  case DIGIT:
    addChar();
    getChar();
    while (charClass == DIGIT) 
    {
      addChar();
      getChar();
    }
    nextToken = INT_LIT;
    break;
  
  case UNKNOWN:
    lookup(nextChar);
      if (nextToken == '\n') 
      {
    	getNewLine();
	printf("Error: Next lexeme not in a valid expression. Moving to next expr. \n\n");
	return nextToken;
      }
    getChar();
  } break;   
  
  printf("Next token is: %d, Next lexeme is %s\n", nextToken, lexeme);
  return nextToken;
} 
/* End of function lex */
    
